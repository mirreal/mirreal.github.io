---
layout: post
title: "关于内存对齐的一点注解"
date: 2014-09-15 14:30:23 +0800
comments: true
categories:
---

## 一、内存对齐的原因

大部分的参考资料都是如是说的：

1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

## 二、对齐规则

#### 每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。比如32位系统默认对齐系数是 4， 64位的则可以达到 8.

<!-- more -->

程序员可以通过预编译命令

```c
#pragma pack(n)  // n=1,2,4,8,16
```

来改变这一系数，其中的n就是指定的“对齐系数”。

另外，可以通过GCC提供的 `__attribute__` 扩展机制取消对齐优化。

### 规则：

1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照 `#pragma pack` 指定的数值和这个数据成员自身长度中，比较小的那个进行。

2. 结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照 `#pragma pack` 指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。


## 三、试验

下面通过一例子的说明这个规则

编译器：GCC4.6.3, (g++)

操作系统：Ubuntu 12， Windows 7

```c
struct test {
  short a;
  double b;
  int c;
  char d;
};
```

在GCC中，各类型的大小如下：

```
sizeof(char)) = 1
sizeof(short) = 2
sizeof(int) = 4
sizeof(float) = 4
sizeof(double) = 8
sizeof(long long) = 8
```

#### 注解：在32位系统，n=4

相当于：

```c
#pragma pack(4)
struct test {
  short a; // 按2字节对齐，存放区间：0-1
  double b; // 按4字节对齐，存放区间：4-11
  int c; // 按4字节对齐，存放区间：12-15
  char d; // 按1字节对齐，存放区间：16
};
#pragma pack()
```

最后整体对齐，按4圆整，故：

```
    sizeof(test) = 20
```

#### 注解：在64位系统，默认的对齐系数为8

```c
struct test {
  short a; // 按2字节对齐，存放区间：0-1
  double b; // 按8字节对齐，存放区间：8-15
  int c; // 按4字节对齐，存放区间：16-19
  char d; // 按1字节对齐，存放区间：20
};
```

最后整体对齐，按8圆整，故：

```
    sizeof(test) = 24
```

#### 注解：C++允许在结构体中定义static变量，静态变量分配在同一的静态存储区，不包含在结构体大小中。

如下：

```c
#pragma pack(4)
struct test {
  short a;
  double b;
  int c;
  char d;
  static int d;
};
#pragma pack()
```

该结构体的大小仍为 20.

在标准C，似乎并没有这种用法。
